# -*- coding: utf-8 -*-
"""OCP1_LST.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hvz2AYlJCNW0DxjG1hvQmoJjoTAlqNRm
"""

!pip install rioxarray
!pip install stackstac
!pip install pystac_client
!pip install planetary_computer
!pip install odc-stac

# Supress Warnings
import warnings
warnings.filterwarnings('ignore')

# Import common GIS tools
import numpy as np
import xarray as xr
import matplotlib.pyplot as plt
import rioxarray as rio
import rasterio
from matplotlib.cm import jet,RdYlGn

# Import Planetary Computer tools
import stackstac
import pystac_client
import planetary_computer
from odc.stac import stac_load

"""### Discover and load the data for analysis

First, we define our area of interest using latitude and longitude coordinates.
"""

# Define the bounding box for the entire data region using (Latitude, Longitude)
# This is the region of New York City that contains our temperature dataset
lower_left = (20.943, 105.866)
upper_right = (21.081, 105.964)

# Calculate the bounds for doing an archive data search
# bounds = (min_lon, min_lat, max_lon, max_lat)
bounds = (lower_left[1], lower_left[0], upper_right[1], upper_right[0])

# Define the time window
# We will use a period of 3 months to search for data
time_window = "2021-06-01/2021-09-01"

stac = pystac_client.Client.open("https://planetarycomputer.microsoft.com/api/stac/v1")

search = stac.search(
    bbox=bounds,
    datetime=time_window,
    collections=["landsat-c2-l2"],
    query={"eo:cloud_cover": {"lt": 50},"platform": {"in": ["landsat-8"]}},
)

items = list(search.get_items())
print('This is the number of scenes that touch our region:',len(items))

signed_items = [planetary_computer.sign(item).to_dict() for item in items]

# Define the pixel resolution for the final product
# Define the scale according to our selected crs, so we will use degrees
resolution = 30  # meters per pixel
scale = resolution / 111320.0 # degrees per pixel for crs=4326

"""### Landsat Band Summary
The following list of bands will be loaded by the Open Data Cube (ODC) stac command:<br>
We will use two load commands to separate the RGB data from the Surface Temperature data.<br><br>
Band 2 = blue = 30m<br>
Band 3 = green = 30m<br>
Band 4 = red = 30m<br>
Band 5 = nir08 (near infrared) = 30m<br>
Band 11 = Surface Temperature = lwir11 = 100m
"""

data1 = stac_load(
    items,
    bands=["red", "green", "blue", "nir08"],
    crs="EPSG:4326", # Latitude-Longitude in coordinate-ref system
    resolution=scale, # Degrees
    chunks={"x": 2048, "y": 2048},
    dtype="uint16",
    patch_url=planetary_computer.sign,
    bbox=bounds
)

data2 = stac_load(
    items,
    bands=["lwir11"],
    crs="EPSG:4326", # Latitude-Longitude
    resolution=scale, # Degrees
    chunks={"x": 2048, "y": 2048},
    dtype="uint16",
    patch_url=planetary_computer.sign,
    bbox=bounds
)

# View the dimensions of our XARRAY and the loaded variables
# This insures we have the right coordinates and spectral bands in our xarray
display(data1)
display(data2)

# Persist the data in memory for faster operations
data1 = data1.persist()
data2 = data2.persist()

"""### Scaling Datasets
Landsat Collection-2 Level-2 products require scaling before creating valid output products. <br>
Scale factors for the RGB and NIR bands differ from scale factors for the Surface Temperature band.<br>
"""

# Scale Factors for the RGB and NIR bands
scale1 = 0.0000275
offset1 = -0.2
data1 = data1.astype(float) * scale1 + offset1

# Scale Factors for the Surface Temperature band
scale2 = 0.00341802
offset2 = 149.0
kelvin_celsius = 273.15 # convert from Kelvin to Celsius
data2 = data2.astype(float) * scale2 + offset2 - kelvin_celsius

"""### View RGB (real color) images from the time series"""

plot_data = data1[["red","green","blue"]].to_array()
plot_data.plot.imshow(col='time', col_wrap=4, robust=True, vmin=0, vmax=0.25)
plt.show()

"""### Output Products

"""

# Pick one of the scenes above (numbering starts with 0)
scene = 0

# Plot an RGB Real Color Image for a single date
fig, ax = plt.subplots(figsize=(9,10))
data1.isel(time=scene)[["red", "green", "blue"]].to_array().plot.imshow(robust=True, ax=ax, vmin=0.0, vmax=0.25)
ax.set_title("RGB Real Color")
ax.axis('off')
plt.show()

"""The <b>Normalized Difference Vegetation Index (NDVI)</b> is used to measure the "greenness" of vegetation and has a range of 0.0 to 1.0. Low values (0.0 to 0.25) reflect a lack of vegetation (bare soil, urban, water), middle values (0.25 to 0.6) reflect grasslands or croplands in their growing state, and high values (0.6 to 1.0) reflect dense vegetation such as trees or croplands at their peak vegetation state. Such information can be relevant to modeling urban heating as the proximity to vegetation or "green space" can mitigate urban heating. The equation uses two spectral bands where: <b>NDVI = (NIR-Red) / (NIR+Red)."""

# Calculate NDVI for the median mosaic
ndvi_data = (data1.isel(time=scene).nir08-data1.isel(time=scene).red)/(data1.isel(time=scene).nir08+data1.isel(time=scene).red)

ndvi_data

fig, ax = plt.subplots(figsize=(11,10))
ndvi_data.plot.imshow(vmin=0.0, vmax=1.0, cmap="RdYlGn")
plt.title("Vegetation Index = NDVI")
plt.axis('off')
plt.show()

"""### Landsat Surface Temperature"""

fig, ax = plt.subplots(figsize=(11,10))
data2.isel(time=scene).lwir11.plot.imshow(vmin=20.0, vmax=45.0, cmap="jet")
plt.title("Land Surface Temperature (LST)")
plt.axis('off')
plt.show()

data2.lwir11

def calculate_uhi_xarray(ndvi: xr.DataArray, lst: xr.DataArray, ndvi_threshold: float = 0.2) -> xr.DataArray:
    """
    Calculate UHI index per urban pixel using xarray DataArrays for NDVI and LST.

    Parameters:
        ndvi (xr.DataArray): NDVI array with 'latitude' and 'longitude' dims.
        lst (xr.DataArray): Land Surface Temperature (°C) with same dims as NDVI.
        ndvi_threshold (float): Threshold to separate urban (< threshold) and rural (>= threshold).

    Returns:
        xr.DataArray: UHI map where UHI is computed only for urban pixels; NaN elsewhere.
    """
    # Create boolean masks
    urban_mask = ndvi < ndvi_threshold
    rural_mask = ndvi >= ndvi_threshold

    # Compute mean LST over the entire region
    global_mean_lst = lst.mean(skipna=True)

    # Compute mean LST in rural areas
    rural_mean_lst = lst.where(rural_mask).mean(skipna=True)

    # Calculate raw UHI in urban areas
    raw_uhi = lst - rural_mean_lst

    # Calculate mean UHI in urban areas only (exclude rural from denominator)
    mean_uhi_urban = raw_uhi.where(urban_mask).mean(skipna=True)

    # Normalize UHI
    # normalized_uhi = xr.where(urban_mask, raw_uhi / mean_uhi_urban, np.nan) # find UHI for urban areas only
    # normalized_uhi = xr.where(urban_mask, lst / global_mean_lst, np.nan)
    normalized_uhi = lst / global_mean_lst

    # Annotate
    normalized_uhi.name = "Normalized_UHI"
    normalized_uhi.attrs["units"] = "relative index"
    normalized_uhi.attrs["description"] = (
        "Normalized Urban Heat Island intensity (UHI / mean UHI in urban areas). "
        "<1 = cooler-than-average, >1 = hotter-than-average."
    )

    return normalized_uhi

uhi_map = calculate_uhi_xarray(ndvi_data, data2.isel(time=scene).lwir11, 0.3) # threshold to classify rural and urban

uhi_map.plot(cmap="hot", figsize=(8, 6))

# Convert to NumPy array for inspection
uhi_array = uhi_map.values  # .values gives the raw NumPy array

# Step 6: Print or inspect the extracted array
print("✅ UHI array shape:", uhi_array.shape)
print("UHI index at each point (sample):")
print(uhi_array[:5, :5])  # Display top-left corner

import csv

def save_uhi_to_csv(uhi_array, latitudes, longitudes, filename):
    """
    Extracts UHI values from a 2D array and saves them to a CSV file.

    Parameters:
    - uhi_array: A 2D array where uhi_array[i][j] is the UHI value at latitude i, longitude j.
    - latitudes: A 1D array or list of latitude values corresponding to the rows of uhi_array.
    - longitudes: A 1D array or list of longitude values corresponding to the columns of uhi_array.
    - filename: The name of the CSV file to save the data.
    """
    # Open the CSV file in write mode
    with open(filename, mode='w', newline='') as file:
        writer = csv.writer(file)

        # Write the header row
        writer.writerow(["Longitude", "Latitude", "UHI Index"])

        # Write each UHI value with corresponding latitude and longitude
        # for i in range(len(uhi_array)):
        #     for j in range(len(uhi_array[i])):
        for i in range(100):
            for j in range(100):
                latitude = latitudes[i]
                longitude = longitudes[j]
                uhi_value = uhi_array[i][j]
                writer.writerow([longitude, latitude, uhi_value])

    print(f"Data has been successfully written to {filename}")

# Extract latitude and longitude ranges from the bounds
lat_min, lon_min = lower_left
lat_max, lon_max = upper_right

# Calculate the latitudes and longitudes based on the shape of uhi_array
latitudes = np.linspace(lat_min, lat_max, uhi_array.shape[0])[:100]  # Generate latitudes based on the array's first dimension (513)
longitudes = np.linspace(lon_min, lon_max, uhi_array.shape[1])[:100]  # Generate longitudes based on the array's second dimension (365)

# Print to verify
print("Latitudes:", latitudes[:5])
print("Latitudes:", len(latitudes))
print("Latitudes:", latitudes[:5])
print("Longitudes:", len(longitudes))

# Assuming latitudes and longitudes are 1D arrays corresponding to each row/column of the UHI map
save_uhi_to_csv(uhi_array, latitudes, longitudes, "OCP_TrainingData(10k).csv")

"""### Save the output data in a GeoTIFF file"""

# Only select one of the time slices to output
data3 = data2.isel(time=scene)

filename = "OCP1_LST.tiff"

# Calculate the dimensions of the file
height = data3.dims["latitude"]
width = data3.dims["longitude"]

# Define the Coordinate Reference System (CRS) to be common Lat-Lon coordinates
# Define the tranformation using our bounding box so the Lat-Lon information is written to the GeoTIFF
gt = rasterio.transform.from_bounds(lower_left[1],lower_left[0],upper_right[1],upper_right[0],width,height)
data3.rio.write_crs("epsg:4326", inplace=True)
data3.rio.write_transform(transform=gt, inplace=True);

# Create the GeoTIFF output file using the defined parameters
with rasterio.open(filename,'w',driver='GTiff',width=width,height=height,
                   crs='epsg:4326',transform=gt,count=1,compress='lzw',dtype='float64') as dst:
    dst.write(data3.lwir11,1)
    dst.close()

# Show the new saved output file
!ls *.tiff

